import { init } from 'license-checker-rseidelsohn';
import { mkdir, readFile, writeFile } from 'node:fs/promises';
import { resolve } from 'node:path';
import { fileURLToPath } from 'node:url';
import { exit } from 'node:process';
import { parseArgs } from 'node:util';

const DEFAULT_CONFIG_FILE_PATH = 'license-config.json';
const DEFAUT_LICENSE_FILES_PATH = 'licences';
const DEFAULT_BUILD_PATH = './dist'; // FUTURE extract compilerOptions/outDir from ./tsconfig.json
const DEFAULT_LICENCES_SUB_PATH = 'third-party-notices.html';

// --- Type Definitions ---
interface LicenseConfig {
  production: boolean;
  allowedLicenses: string[];
  excludedPackages?: string[];
  out?: string;
  files?: string;
  htmlOut?: string;
}

interface CheckerOptions {
  start: string;
  production: boolean;
  onlyAllow: string;
  excludePackages?: string;
  out?: string;
  files?: string;
  [key: string]: any;
}

interface LicenseData {
  licenses?: string | string[]; // licenses is optional to handle missing data
  repository?: string;
  publisher?: string;
  email?: string;
  path?: string;
  licenseFile?: string;
}

interface CheckerResult {
  [packageName: string]: LicenseData;
}

// --- Helper: Parse Arguments ---
function getArgs() {
  const { values } = parseArgs({
    args: process.argv.slice(2),
    options: {
      config: {
        type: 'string',
        short: 'c',
        default: DEFAULT_CONFIG_FILE_PATH
      },
      summary: {
        type: 'boolean',
        short: 's',
        default: false
      }
    }
  });
  return values;
}

// --- HTML Generator Helper ---
async function generateHtmlReport(packages: CheckerResult, outputPath: string) {
  console.log(`üìù Generating HTML report at: ${outputPath}`);

  let htmlContent = `
  <!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Third-Party Software Notices</title>
    <style>
      body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.6; color: #333; max-width: 900px; margin: 0 auto; padding: 20px; }
      h1 { border-bottom: 2px solid #eee; padding-bottom: 10px; }
      .component { border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px; padding: 10px; background: #fafafa; }
      .header { display: flex; justify-content: space-between; align-items: center; }
      .meta { font-size: 0.9em; color: #666; }
      details { margin-top: 10px; }
      summary { cursor: pointer; font-weight: bold; color: #0066cc; outline: none; }
      pre { background: #fff; padding: 15px; overflow-x: auto; border: 1px solid #eee; font-size: 0.85em; }
      a { color: #0066cc; text-decoration: none; }
      a:hover { text-decoration: underline; }
    </style>
  </head>
  <body>
    <h1>Third-Party Software Notices</h1>
    <p>This software includes the following third-party components. We thank the open source community for their contributions.</p>
  `;

  for (const [pkgName, data] of Object.entries(packages)) {
    const rawLicense = data.licenses || 'UNKNOWN';
    const licenseType = Array.isArray(rawLicense) ? rawLicense.join(' OR ') : rawLicense;
    const repoUrl = data.repository
      ? `<a href="${data.repository}" target="_blank">Source</a>`
      : '';

    // Attempt to read the license text
    let licenseText = 'License text not found in package.';
    if (data.licenseFile) {
      try {
        licenseText = await readFile(data.licenseFile, 'utf-8');
      } catch (e) {
        // failed to read file, keep default message
      }
    }

    // Escape HTML in license text to prevent rendering issues
    const safeText = licenseText.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');

    htmlContent += `
    <div class="component">
      <div class="header">
        <strong>${pkgName}</strong>
        <span class="meta">${licenseType} &nbsp; ${repoUrl}</span>
      </div>
      <details>
        <summary>View License Agreement</summary>
        <pre>${safeText}</pre>
      </details>
    </div>
    `;
  }

  htmlContent += `
    <footer style="margin-top: 50px; text-align: center; font-size: 0.8em; color: #999;">
      Generated by License Audit Script
    </footer>
  </body>
  </html>
  `;

  await writeFile(outputPath, htmlContent);
}

// --- Main Execution ---
async function runAudit() {
  const args = getArgs();
  const rootDir = resolve(fileURLToPath(new URL('..', import.meta.url)));

  // Resolve config path relative to where the command is run, or default to root
  const configPath = resolve(process.cwd(), args.config!);

  console.log(`üìÑ Reading configuration from: ${configPath}`);

  let config: LicenseConfig;

  try {
    const fileContent = await readFile(configPath, 'utf-8');
    config = JSON.parse(fileContent);
  } catch (error) {
    console.error(`‚ùå Failed to read configuration file: ${(error as Error).message}`);
    exit(1);
  }

  // Ensure the directory for license files exists if requested
  // empty string selects the default path, see DEFAUT_LICENSE_FILES_PATH
  // to get the root path, use '.' or './'
  if (config.files != null) {
    const configFilesPath = config.files.trim() || DEFAUT_LICENSE_FILES_PATH;
    const filesDirPath = resolve(process.cwd(), configFilesPath);
    await mkdir(filesDirPath, { recursive: true });
    console.log(`üìÇ License files will be copied to: ${filesDirPath}`);
  }

  if (config.htmlOut != null) {
    const configHtmlOutPath = config.htmlOut.trim() || DEFAULT_LICENCES_SUB_PATH;
    // Ensure the parent directory for the HTML file exists
    // FUTURE try to extract compilerOptions/outDir from ./tsconfig.json befor using DEFAULT_BUILD_PATH
    const htmlDirPath = resolve(process.cwd(), DEFAULT_BUILD_PATH, configHtmlOutPath, '..');
    await mkdir(htmlDirPath, { recursive: true });
    console.log(`üìÇ WEB License HTML page will be copied to: ${htmlDirPath}`);
  }

  // We explicitly set 'summary: false' in options because we want the full raw data
  // to generate our own "Dual Output" (List + Summary) if requested.
  // Transform arrays into semicolon-separated strings required by the tool
  const checkerOptions: CheckerOptions = {
    start: rootDir,
    production: config.production,
    summary: false,
    onlyAllow: config.allowedLicenses.join(';'),
    excludePackages: config.excludedPackages?.join(';'),
    out: config.out,
    files: config.files?.trim()
      ? config.files
      : config.files != null
        ? DEFAUT_LICENSE_FILES_PATH
        : undefined
  };

  if (config.out) {
    console.log(`üíæ Output will be written to: ${config.out}`);
  } else {
    console.log('üîç Starting license audit...');
  }

  // The library uses a callback pattern, so we wrap it in a Promise to use async/await
  const auditPromise = new Promise<CheckerResult>((resolve, reject) => {
    init(checkerOptions, (err: Error | null, packages: CheckerResult) => {
      if (err) {
        // The tool returns an error object if forbidden licenses are found
        reject(err);
      } else {
        resolve(packages);
      }
    });
  });

  try {
    const packages = await auditPromise;

    // 1. Generate HTML if requested
    if (config.htmlOut != null) {
      const configHtmlOutPath = config.htmlOut.trim() || DEFAULT_LICENCES_SUB_PATH;
      const htmlFilePath = resolve(process.cwd(), DEFAULT_BUILD_PATH, configHtmlOutPath);
      const htmlPath = resolve(process.cwd(), htmlFilePath);
      await generateHtmlReport(packages, htmlPath);
    }

    // 2. Console logging detailed list only if not writing to a specific 'out' file
    //    using a format similar to --plainVertical
    if (!config.out) {
      console.log('\n--- üì¶ Full Dependency List ---');
      Object.entries(packages).forEach(([pkgName, data]) => {
        console.log(pkgName);

        const rawLicense = data.licenses || 'UNKNOWN';
        const licenseStr = Array.isArray(rawLicense) ? rawLicense.join(' OR ') : rawLicense;

        console.log(`  licenses: ${licenseStr}`);
        if (data.repository) console.log(`  repository: ${data.repository}`);
        if (data.publisher) console.log(`  publisher: ${data.publisher}`);
        if (data.email) console.log(`  email: ${data.email}`);
        console.log(''); // Newline separator
      });
    }

    // 3. Conditionally print the summary at the bottom
    if (args.summary) {
      console.log('\n--- üìä License Summary ---');
      const summaryCount: Record<string, number> = {};

      Object.values(packages).forEach((data) => {
        const rawLicenses = data.licenses || 'UNKNOWN';
        const licenses = Array.isArray(rawLicenses) ? `(${rawLicenses.join(' OR ')})` : rawLicenses;

        summaryCount[licenses] = (summaryCount[licenses] || 0) + 1;
      });

      // Print sorted summary
      Object.entries(summaryCount)
        .sort(([, a], [, b]) => b - a) // Sort by count descending
        .forEach(([license, count]) => {
          console.log(`${license}: ${count}`);
        });
      console.log('--------------------------');
    }

    console.log('\n‚úÖ License Audit Passed: All production dependencies are compliant.');
    exit(0);
  } catch (error) {
    console.error('\n‚ùå LICENSE AUDIT FAILED');
    console.error('The following forbidden licenses were found or an error occurred:');
    console.error((error as Error).message);
    exit(1);
  }
}

runAudit();
