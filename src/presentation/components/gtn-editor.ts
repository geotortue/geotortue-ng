import { LitElement, html, css, type PropertyValues } from 'lit';
import { customElement, property, query } from 'lit/decorators.js';
import { basicSetup } from 'codemirror';
import { autocompletion, type CompletionContext } from '@codemirror/autocomplete';
import { indentWithTab } from '@codemirror/commands';
import { Compartment, EditorState } from '@codemirror/state';
import { oneDark } from '@codemirror/theme-one-dark';
import { EditorView, keymap } from '@codemirror/view';

import type { IGTNLanguageService } from '@domain/interfaces/IGTNLanguageService';
import { GeoTortueSyntaxService } from '@domain/services/GeoTortueSyntaxService';
import { GTNContainer } from '@infrastructure/di/GTNContainer';
import { GTN_TYPES } from '@infrastructure/di/GTNTypes';
import { UiLanguageController } from '@ui/controllers/UiLanguageController';

import { createAntlrHighlighter } from '@ui/editor/syntax/createAntlrHighlighter';
import { geoTortueSyntaxTheme } from '@ui/editor/themes/geoTortueSyntaxTheme';

@customElement('gtn-editor')
export class GTNEditor extends LitElement {
  static override readonly styles = css`
    :host {
      display: block;
      height: 100%;
      overflow: hidden;
      // text-align: left;
      font-size: 14px;
    }
    #editor-container {
      height: 100%;
    }
    .cm-editor {
      height: 100%;
    }
    .cm-scroller {
      font-family: 'Inconsolata', monospace;
    }
  `;

  @property({ type: String })
  accessor code: string = ''; // ex value with 'FORWARD 50\nRIGHT 90\nFORWARD 50';

  @query('#editor-container')
  private accessor editorContainer!: HTMLDivElement; // ex container

  private editor?: EditorView; // ex editorView

  private readonly langService: IGTNLanguageService;

  // Controller to listen for changes
  private readonly langController = new UiLanguageController(this);

  // Compartment to allow dynamic reconfiguration of language features
  private readonly languageCompartment = new Compartment();
  private readonly syntaxService: GeoTortueSyntaxService;

  constructor() {
    super();
    const container = GTNContainer.getInstance();
    this.langService = container.resolve<IGTNLanguageService>(GTN_TYPES.LanguageService);
    this.syntaxService = container.resolve<GeoTortueSyntaxService>(GTN_TYPES.SyntaxService);
  }

  protected override firstUpdated(): void {
    this.initEditor();
  }

  private initEditor() {
    const highlighterExtension = createAntlrHighlighter(this.syntaxService, this.langService);

    const startState = EditorState.create({
      doc: this.code,
      extensions: [
        basicSetup, // See https://codemirror.net/docs/ref/#codemirror.basicSetup
        keymap.of([indentWithTab]),
        oneDark,
        geoTortueSyntaxTheme,
        highlighterExtension,
        // Register the compartment for dynamic extensions
        this.languageCompartment.of([highlighterExtension]),
        EditorView.updateListener.of((update) => {
          if (!update.docChanged) {
            return;
          }

          // Note: In standard accessors, setting 'this.code' triggers the setter logic generated by Lit
          this.code = update.state.doc.toString();
          // Emit event so parent knows code changed
          this.dispatchEvent(
            new CustomEvent('code-change', {
              detail: { code: this.code },
              bubbles: true, // A boolean value indicating whether the event bubbles. The default is false.
              composed: true // A boolean value indicating whether the event will trigger listeners outside of a shadow root (see Event.composed for more details). The default is false.
            })
          );
        })
      ]
    });

    this.editor = new EditorView({
      state: startState,
      parent: this.editorContainer
    });

    // Initial configuration
    this.updateLanguageFeatures();
  }

  // Called whenever properties change OR when UiLanguageController requests update
  /**
   * LIFECYCLE HOOK: Called when properties change.
   * This is where we catch the "Data Down" update from GTNApp.
   */
  protected updated(changedProperties: PropertyValues): void {
    super.updated(changedProperties);

    // If the DSL language changed (we can check service vs internal state,
    // but reconfiguring the compartment is cheap enough to do on update)
    this.updateLanguageFeatures();
    this.translateCodeInEditor(changedProperties);
  }

  private translateCodeInEditor(changedProperties: PropertyValues): void {
    // Check if 'code' prop changed and we have an editor view...
    if (!changedProperties.has('code') || !this.editor) {
      return;
    }

    const editorContent = this.editor.state.doc.toString();

    // If the new prop value is different from what's in the editor
    // (This happens when translation occurs, or file is opened)
    if (editorContent === this.code) {
      return;
    }

    this.editor.dispatch({
      changes: {
        from: 0,
        to: editorContent.length,
        insert: this.code
      }
    });
  }

  private updateLanguageFeatures() {
    if (!this.editor) {
      return;
    }

    // 1. Get current keywords from service
    const keywords = this.langService.getAllKeywords();

    // 2. Define Autocomplete Extension
    const completionExtension = autocompletion({
      override: [
        (context: CompletionContext) => {
          const word = context.matchBefore(/\w*/);
          if (!word || (word.from === word.to && !context.explicit)) return null;

          return {
            from: word.from,
            options: keywords.map((kw) => ({ label: kw, type: 'keyword' }))
          };
        }
      ]
    });

    // 3. Dispatch effect to update the compartment
    this.editor.dispatch({
      effects: this.languageCompartment.reconfigure([
        completionExtension,
        createAntlrHighlighter(this.syntaxService, this.langService)
      ])
    });
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    this.editor?.destroy();
  }

  render() {
    return html`<div id="editor-container"></div>`;
  }
}
